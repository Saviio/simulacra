<!DOCTYPE html><!--

Simulacra.js
https://github.com/0x8890/simulacra

--><meta charset="utf-8"><title>Simulacra.js</title><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="index.css"><link href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPGH6FLiRNz/////////////////4kTc/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOQwwP/kPt7///3///79///////////////////iRNz/4kTc/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOIwq//iLMz/5Dze//rm+f/77vv//fP9//71
/f/++/7/40Lc/+ND3P/jKdH/AAAAAAAAAAAAAAAAAAAAAORRpvzgM5n/4zDD/+Mu1//2vvH/4jLW//fQ9f/52ff/+eL4/+Is0P/jLdb/5C+//+Muw/8AAAAAAAAAAAAAAAAAAAAA3DeM/+Qwtv/jKdH/4irQ/++W6f/xoOv/8qvu/+Mu1//jLcf/4izM/+IwsP/zntmFAAAAAAAAAAAAAAAAAAAAANw3hf/i
MKb/4yzN/+IrzP/mV+D/52bi/+In0P/jKdH/5C65/+Mwv//jMLn/4DOe/wAAAAAAAAAAAAAAAAAAAADbOH3/4DOe/+Azpv/gM6L/4kTc/+JE3P/iLMz/4yzN/+Mxsf/jMLH/3zWM/980kP8AAAAAAAAAAAAAAAAAAAAA2jh1/981kP/eNY//3zWW/+Mtwv/iLML/4ivG/+Aznv/gM6L/3DeB/9w3iP8AAAAA
AAAAAAAAAAAAAAAAAAAAANk4cP/cN4X/2zh9/9w3iP/kL7//4y6+/+Qvv//fNZH/2jd4//CVvw3bOH3/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2Tht/9k4bf/bOH3/5C+6/+Quuf/cN4X/3DeF/9o4df8AAAAA2DN0/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPGow2nZOGn/2zh9/+Qwtv/kMLb/2zh9
/9k4bf/ZOHD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANs4ff/bOH3/2zh5/9s4ff/ZOGn/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADROFv/2zh9/9s4ff/YOmP/2Dpj/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAMY6UP/cN33/yzpX/806V/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvDlD/8A6R//DOUr/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgpbUStTg+/wAAAAAAAAAAAAAAAAAAAAAA
AAAA+B8AAPAHAADgAwAAwAEAAOABAADgAQAA4AEAAOADAADgAwAA8AsAAPAPAAD8HwAA/B8AAP4fAAD/HwAA/58AAA==" rel="icon" type="image/x-icon"><script src="simulacra.min.js"></script><header><h1>Simulacra.js</h1><h2>Reactive data binding for web applications.</h2><code>npm i simulacra --save #v<span class="version">1.3.2</span></code> <a href="simulacra.min.js" class="button">Download</a> <a href="https://github.com/0x8890/simulacra" id="corner"><span>Fork on </span>GitHub</a></header><article><h2 id="synopsis">Synopsis<a class="anchor" href="#synopsis" title="Link to this section “Synopsis”">#</a></h2><p>Simulacra.js handles DOM interactions in reaction to changes in data. When data changes, it maps those changes to the DOM by adding and removing elements and invoking <em>change</em> functions, which by default, assign plain text and form input values.</p><p>It emphasizes <a href="#benchmarks">performance</a> and terseness, and it has no dependencies. The approximate size of this library is ~4 KB (minified and gzipped).</p><h2 id="usage">Usage<a class="anchor" href="#usage" title="Link to this section “Usage”">#</a></h2><div><p>Simulacra.js exports only a single function that is used to bind an object to the DOM, that is its entire API surface area. Here is an example of Simulacra.js in action:</p><div class="example"><div class="container"><div class="left"><div class="product-container"></div></div><div class="right"><p>Live demo, try it out:</p><ul><li><code>data.name = "Caramel Latte"</code></li><li><code>data.details.size.push("Trenta")</code></li><li><code>data.details.size = [ 'Tall' ]</code></li></ul><input type="text" name="eval" placeholder="Change data..."></div></div></div><template id="product"><h1 class="name"></h1><div class="details"><div><span class="size"></span></div><hr><h4 class="vendor"></h4></div></template><script>void function () {
  var simulacra = window.simulacra
  var data = window.data = {
    name: 'Pumpkin Spice Latte',
    details: {
      meta: {
        date: new Date()
      },
      size: [ 'Tall', 'Grande', 'Venti' ],
      vendor: 'Starbucks'
    }
  }

  var fragment = document.getElementById('product').content
  var input = document.querySelector('input[name="eval"]')

  simulacra.useCommentNode = true

  document.querySelector('.product-container').appendChild(
    simulacra(data, [ fragment, {
      name: '.name',
      details: [ '.details', {
        meta: {
          date: function (node, value) {
            node.dataset.timestamp = value.getTime()
          }
        },
        size: '.size',
        vendor: '.vendor'
      } ]
    } ]))

  input.addEventListener('keyup', function (event) {
    if (event.keyCode === 13) {
      var x = input.value
      try {
        eval(x)
        input.value = ''
      }
      catch (error) { alert(error) }
    }
  })
}()</script></div><p>Simulacra.js uses plain HTML for templating, and it does not require any meta-information in the template. This makes it straightforward to start with a static HTML page and add interactive parts. Here's a sample template:</p><pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"product"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"name"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"details"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"size"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"vendor"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre><p>Using the <code>&lt;template&gt;</code> tag is optional, but any DOM element will suffice. The shape of the data is important since it has a straightforward mapping to the DOM, and arrays are iterated over to output multiple DOM elements. Here's some sample data:</p><pre><code class="lang-js"><span class="hljs-title">var</span> <span class="hljs-class"><span class="hljs-keyword">data</span> = {
  <span class="hljs-title">name</span>: '<span class="hljs-type">Pumpkin</span> <span class="hljs-type">Spice</span> <span class="hljs-type">Latte</span>',
  <span class="hljs-title">details</span>: {
    <span class="hljs-title">size</span>: [ '<span class="hljs-type">Tall</span>', '<span class="hljs-type">Grande</span>', '<span class="hljs-type">Venti</span>' ],
    <span class="hljs-title">vendor</span>: '<span class="hljs-type">Starbucks</span>'
  }</span>
}
</code></pre><p>Simulacra.js exports only a single function, which binds an object to the DOM. The first argument must be a singular object, and the second argument is a data structure that defines the bindings. The definition must be a CSS selector string, DOM Node, <em>change</em> function or definition object (parent binding only), or an array with at most three elements:</p><ul><li><strong>Index 0</strong>: either a DOM element or a CSS selector string.</li><li><strong>Index 1</strong>: either a definition object, or a <em>change</em> function.</li><li><strong>Index 2</strong>: if index 1 is a definition object, this may be a <em>change</em> function.</li></ul><pre><code class="lang-js"><span class="hljs-selector-tag">var</span> simulacra = require(<span class="hljs-string">'simulacra'</span>) <span class="hljs-comment">// or `window.simulacra`</span>
<span class="hljs-selector-tag">var</span> fragment = document.getElementById(<span class="hljs-string">'product'</span>)<span class="hljs-selector-class">.content</span>

<span class="hljs-selector-tag">var</span> node = simulacra(data, [ fragment, {
  name: <span class="hljs-string">'.name'</span>,
  <span class="hljs-selector-tag">details</span>: [ <span class="hljs-string">'.details'</span>, {
    size: <span class="hljs-string">'.size'</span>,
    vendor: <span class="hljs-string">'.vendor'</span>
  } ]
} ])

document<span class="hljs-selector-class">.body</span><span class="hljs-selector-class">.appendChild</span>(node)
</code></pre><p>The DOM will update if any of the bound keys are assigned a different value, or if any <code>Array.prototype</code> methods on the value are invoked. Arrays and single values may be used interchangeably, the only difference is that Simulacra.js will iterate over array values.</p><h2 id="change-function">Change Function<a class="anchor" href="#change-function" title="Link to this section “Change Function”">#</a></h2><p>By default, the value will be assigned to the element's <code>textContent</code> property (or <code>value</code> or <code>checked</code> for inputs). A user-defined <em>change</em> function may be passed for arbitrary element manipulation, and its return value determines the new <code>textContent</code>, <code>value</code>, or <code>checked</code> attribute if it is not applied on a definition object. The <em>change</em> function may be passed as the second or third position, it has the signature (<code>element</code>, <code>value</code>, <code>previousValue</code>, <code>path</code>):</p><ul><li><strong><code>element</code></strong>: the local DOM element.</li><li><strong><code>value</code></strong>: the value assigned to the key of the bound object.</li><li><strong><code>previousValue</code></strong>: the previous value assigned to the key of the bound object.</li><li><strong><code>path</code></strong>: an array containing the full path to the value. For example: <code>[ 'users', 2, 'email' ]</code>. Integer values indicate array indices. The root object is accessible at the <code>root</code> property of the path array, i.e. <code>path.root</code>, and the deepest bound object is accessible at the <code>target</code> property, i.e. <code>path.target</code>.</li></ul><p>To manipulate an element in a custom way, one may define a <em>change</em> function like so:</p><pre><code class="lang-js">[ selector, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(element, value, previousValue)</span> </span>{
  <span class="hljs-comment">// Attach listeners before inserting a DOM Node.</span>
  <span class="hljs-keyword">if</span> (previousValue === <span class="hljs-literal">null</span>)
    element.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      alert(<span class="hljs-string">'clicked'</span>)
    })

  <span class="hljs-keyword">return</span> <span class="hljs-string">'Hi '</span> + value + <span class="hljs-string">'!'</span>
} ]
</code></pre><p>A <em>change</em> function can be determined to be an insert, mutate, or remove operation based on whether the value or previous value is <code>null</code>:</p><ul><li><strong>Value but not previous value</strong>: insert operation.</li><li><strong>Value and previous value</strong>: mutate operation.</li><li><strong>No value</strong>: remove operation.</li></ul><p>There are some special cases for the <em>change</em> function:</p><ul><li>If the bound element is an <code>input</code> or a <code>textarea</code>, the default behavior will be to update the data when the input changes. This may be overridden with a custom change function.</li><li>If the bound element is the same as its parent, its value will not be iterated over if it is an array.</li><li>If the <em>change</em> function returns <code>simulacra.retainElement</code> for a remove operation, then <code>Node.removeChild</code> will not be called. This is useful for implementing animations when removing an element from the DOM.</li><li>If the change function is applied on a definition object, it will never be a mutate operation, it will first remove and then insert in case of setting a new object over an existing object.</li></ul><h2 id="data-binding">Data Binding<a class="anchor" href="#data-binding" title="Link to this section “Data Binding”">#</a></h2><p>The idea is that once the bindings have been set up, one does not call Simulacra.js again. For example, assigning <code>data.name = 'Simulacra'</code> by default will set the text of the element to that value and append it to the DOM if it doesn't exist, and <code>data.name = null</code> will remove all elements corresponding to that field. Assigning <code>data.name = ['John', 'Doe']</code> will create missing elements and assign the text of both elements, and append them if necessary.</p><p>The bindings work recursively on objects, which provides a simple way to build complex user interfaces. For example, assigning <code>data.details = { size: [1, 2, 3], vendor: 'X' }</code> will create the element for <code>details</code> and the child elements corresponding to its fields (<code>size</code>, <code>vendor</code>, etc), and remove the previous element if it existed. The new object also has bindings, so <code>data.details.size.push(4)</code> will create a new element corresponding to that value.</p><p>All values that are bound to non-parent elements are arrays internally, which will be mapped to elements. For example, a list of things may be modelled as an array of objects: <code>[ {...}, {...}, {...} ]</code>. The arrays which are bound also have instance-specific methods for efficient DOM manipulation, i.e. <code>array.splice(2, 0, { ... })</code> will insert a new element at index <code>2</code> without touching the other elements.</p><p>What Simulacra.js does is capture the intent of the state change, so it is important to use the correct semantics. Using <code>data.details = { ... }</code> is different from <code>Object.assign(data.details, { ... })</code>, the former will assume that the entire object changed and remove and append a new element, while the latter will re-use the same element and check the differences in the key values. For arrays, it is almost always more efficient to use the proper array mutator methods (<code>push</code>, <code>splice</code>, <code>pop</code>, etc). This is also important for implementing animations, since it determines whether elements are created, updated, or removed.</p><h2 id="benchmarks">Benchmarks<a class="anchor" href="#benchmarks" title="Link to this section “Benchmarks”">#</a></h2><p>Simulacra.js is pretty fast in the <a href="http://simulacra.js.org/dbmonster/">DBMonster benchmark</a>. In initial rendering speed based on the <a href="https://lhorie.github.io/mithril/benchmarks.html">benchmarks</a> from Mithril.js, here's how it compares. Tests ran on a Linux desktop using Chromium.</p><div class="table-wrapper"><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:left">Loading</th><th style="text-align:left">Scripting</th><th style="text-align:left">Rendering</th><th style="text-align:left">Aggregate</th></tr></thead><tbody><tr><td style="text-align:left"><em>appendChild</em></td><td style="text-align:left">10 ms</td><td style="text-align:left">3 ms</td><td style="text-align:left">13 ms</td><td style="text-align:left">38 ms</td></tr><tr><td style="text-align:left">Simulacra.js</td><td style="text-align:left">9 ms</td><td style="text-align:left">9 ms</td><td style="text-align:left">13 ms</td><td style="text-align:left">39 ms</td></tr><tr><td style="text-align:left">React.js</td><td style="text-align:left">23 ms</td><td style="text-align:left">76 ms</td><td style="text-align:left">13 ms</td><td style="text-align:left">129 ms</td></tr><tr><td style="text-align:left">Mithril.js</td><td style="text-align:left">16 ms</td><td style="text-align:left">77 ms</td><td style="text-align:left">23 ms</td><td style="text-align:left">165 ms</td></tr><tr><td style="text-align:left">Backbone</td><td style="text-align:left">20 ms</td><td style="text-align:left">106 ms</td><td style="text-align:left">23 ms</td><td style="text-align:left">191 ms</td></tr><tr><td style="text-align:left">jQuery</td><td style="text-align:left">20 ms</td><td style="text-align:left">119 ms</td><td style="text-align:left">24 ms</td><td style="text-align:left">211 ms</td></tr><tr><td style="text-align:left">Angular.js</td><td style="text-align:left">17 ms</td><td style="text-align:left">159 ms</td><td style="text-align:left">24 ms</td><td style="text-align:left">295 ms</td></tr></tbody></table></div><p>To run the benchmarks, you will have to clone the repository and build it by running <code>npm run build</code>. The benchmarks are located <a href="https://github.com/0x8890/simulacra/tree/master/benchmark">here</a>.</p><h2 id="how-it-works">How it Works<a class="anchor" href="#how-it-works" title="Link to this section “How it Works”">#</a></h2><p>On initialization, Simulacra.js replaces bound elements from the template with empty text nodes (markers) for memoizing their positions. Based on a value in the bound data object, it clones template elements and applies the <em>change</em> function on the cloned elements, and appends them near the marker or adjacent nodes.</p><p>When a bound key is assigned, it gets internally casted into an array if it is not an array already, and the values of the array are compared with previous values. Based on whether a value at an index has changed, Simulacra.js will remove, insert, or mutate a DOM element corresponding to the value. This is faster and simpler than diffing changes between DOM trees.</p><h2 id="caveats">Caveats<a class="anchor" href="#caveats" title="Link to this section “Caveats”">#</a></h2><ul><li>The <code>delete</code> keyword will not trigger a DOM update. Although ES6 <code>Proxy</code> has a trap for this keyword, its browser support is lacking and it can not be polyfilled. Also, it would break the API of Simulacra.js for this one feature, so the recommended practice is to set the value to <code>null</code> rather than trying to <code>delete</code> the key.</li><li>Out-of-bounds array index assignment will not work, because the number of setters is equal to the length of the array. Similarly, setting the length of an array will not work because a setter can't be defined on the <code>length</code> property.</li><li>The bound data object may not contain any conflicting getters &amp; setters, since they will be overridden by Simulacra.js.</li><li>Using <code>bind</code>, <code>call</code>, <code>apply</code>, with <code>Array.prototype</code> on bound arrays won't work, because the bound arrays implement instance methods.</li></ul><h2 id="under-the-hood">Under the Hood<a class="anchor" href="#under-the-hood" title="Link to this section “Under the Hood”">#</a></h2><p>This library is written in ES5 syntactically, and requires:</p><ul><li><strong>Object.defineProperty</strong> (ES5): used for binding keys on objects.</li><li><strong>Object.freeze</strong> (ES5.1): used to prevent internal state from being mutated.</li><li><strong>WeakMap</strong> (ES6): memory efficient mapping of DOM nodes.</li></ul><p>It also requires these DOM API features:</p><ul><li><strong>Document.createDocumentFragment</strong> (DOM Level 2): used for bulk insertions.</li><li><strong>Node.appendChild</strong> (DOM Level 1): used for inserting elements in to document fragments.</li><li><strong>Node.contains</strong> (DOM Living Standard): used for checking if bound elements are valid.</li><li><strong>Node.insertBefore</strong> (DOM Level 1): used for inserting document fragments.</li><li><strong>Node.isEqualNode</strong> (DOM Level 3): used for equality checking after cloning nodes.</li><li><strong>Node.removeChild</strong> (DOM Level 1): used for removing elements.</li><li><strong>TreeWalker</strong> (DOM Level 2): fast iteration through DOM nodes.</li></ul><p>No shims are included. At the bare minimum, it works in IE9+ with a WeakMap polyfill, but otherwise it should work in IE11+.</p><h2 id="server-side-rendering">Server-Side Rendering<a class="anchor" href="#server-side-rendering" title="Link to this section “Server-Side Rendering”">#</a></h2><p>Simulacra.js works in Node.js (it's isomorphic!), with one thing to keep in mind: it should be called within the context of the <code>window</code> global, however this may be optional in some implementations. This is most easily done by using <code>Function.prototype.bind</code>, although <code>Function.prototype.call</code> is more performant. In the following example, <a href="https://github.com/fgnass/domino">Domino</a> is used as the DOM implementation.</p><pre><code class="lang-js"><span class="hljs-keyword">const</span> domino = <span class="hljs-built_in">require</span>(<span class="hljs-string">'domino'</span>)
<span class="hljs-keyword">const</span> simulacra = <span class="hljs-built_in">require</span>(<span class="hljs-string">'simulacra'</span>)

<span class="hljs-keyword">const</span> <span class="hljs-built_in">window</span> = domino.createWindow(<span class="hljs-string">'&lt;h1&gt;&lt;/h1&gt;'</span>)
<span class="hljs-keyword">const</span> $ = simulacra.bind(<span class="hljs-built_in">window</span>)
<span class="hljs-keyword">const</span> data = { message: <span class="hljs-string">'Hello world!'</span> }
<span class="hljs-keyword">const</span> binding = [ <span class="hljs-string">'body'</span>, {
  message: <span class="hljs-string">'h1'</span>
} ]

<span class="hljs-built_in">console</span>.log($(data, binding).innerHTML)
</code></pre><p>This will print the string <code>&lt;h1&gt;Hello world!&lt;/h1&gt;</code> to <code>stdout</code>.</p><h2 id="license">License<a class="anchor" href="#license" title="Link to this section “License”">#</a></h2><p>This software is licensed under the <a href="https://raw.githubusercontent.com/0x8890/simulacra/master/LICENSE">MIT license</a>.</p></article>